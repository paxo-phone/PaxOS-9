#include "gsm2.hpp"

#include <chrono>
#include <string>
#include <vector>
#include <memory>
#include <functional>
#include <sstream>
#include <algorithm>
#include <atomic> // For thread-safe flags if needed
#include <cstdio> // For sscanf
#include <iostream>
#include <cmath> // For ceil
#include <iomanip> // For std::setw, std::setfill
#include <stdexcept> // For exceptions in helpers (optional)

#include <delay.hpp> // Assumes PaxOS_Delay
#include <threads.hpp> // Assumes eventHandlerBack

#ifdef ESP_PLATFORM
    #include <Arduino.h>

    #ifndef RX
    #define RX 26
    #endif

    #ifndef TX
    #define TX 27
    #endif

    #ifndef GSM_PWR_PIN
    #define GSM_PWR_PIN 32
    #endif
#endif


namespace Gsm
{
    // --- Internal State Variables ---

    EventHandler eventHandlerGsm;

    // Network Quality
    static int currentRssi = 99;
    static int currentBer = 99;
    static bool networkQualityValid = false;
    static std::chrono::steady_clock::time_point lastQualityUpdateTime;

    // Connection Status (GPRS Attachment)
    static bool isGprsAttached = false;
    static bool gprsStateValid = false;
    static std::chrono::steady_clock::time_point lastGprsUpdateTime;

    // Flight Mode
    static bool flightModeState = false; // Based on AT+CFUN? result (1=ON, 4=OFF)
    static bool flightModeStateValid = false;
    static std::chrono::steady_clock::time_point lastFlightModeUpdateTime;

    // Voltage
    static int currentVoltage_mV = -1;
    std::vector<float> battery_voltage_history;
    static bool voltageValid = false;
    static std::chrono::steady_clock::time_point lastVoltageUpdateTime;

    // PIN Status
    static bool pinRequiresPin = true; // Assume PIN needed until checked
    static bool pinStatusValid = false;
    static std::chrono::steady_clock::time_point lastPinStatusUpdateTime;

    // PDU Mode
    static bool pduModeEnabled = false; // Assume Text mode until checked
    static bool pduModeStateValid = false;
    static std::chrono::steady_clock::time_point lastPduModeUpdateTime;

    // Call State & Info
    static CallState currentCallState = CallState::UNKNOWN;
    static std::string lastIncomingCallNumber = "";

    // Request Queue & Current Request (Internal)
    static std::vector<std::shared_ptr<Request>> requests;
    static std::shared_ptr<Request> currentRequest = nullptr;

    // --- Time Sub-Namespace Implementation ---
    namespace Time
    {
        // Internal state for time
        static int year = -1;
        static int month = -1;
        static int day = -1;
        static int hour = -1;
        static int minute = -1;
        static int second = -1;
        static int timezoneOffsetQuarterHours = 0; // e.g., +4 for UTC+1
        static bool timeValid = false;
        static std::chrono::steady_clock::time_point lastTimeUpdateTime;

        // Enqueues a request to check AT+CCLK?
        static void updateTimeInternal() {
            auto request = std::make_shared<Request>();
            request->command = "AT+CCLK?";
            request->callback = [](const std::string& response) -> bool {
                // Expected format: +CCLK: "yy/MM/dd,hh:mm:ss+/-zz"
                // Example: +CCLK: "24/05/04,21:33:00+08" (UTC+2)

                int l_yy, l_MM, l_dd, l_hh, l_mm, l_ss, l_zz;
                char sign;
                bool parsed_ok = false;

                size_t start_pos = response.find("+CCLK:");
                if (start_pos != std::string::npos) {
                    size_t quote_start = response.find('"', start_pos);
                    size_t quote_end = std::string::npos;
                    if (quote_start != std::string::npos) {
                        quote_end = response.find('"', quote_start + 1);
                    }

                    if (quote_start != std::string::npos && quote_end != std::string::npos) {
                        std::string time_str = response.substr(quote_start + 1, quote_end - quote_start - 1);
                        // Use sscanf for potentially easier parsing of the fixed format
                        int fields_read = sscanf(time_str.c_str(), "%d/%d/%d,%d:%d:%d%c%d",
                                                 &l_yy, &l_MM, &l_dd, &l_hh, &l_mm, &l_ss, &sign, &l_zz);

                        if (fields_read == 8) { // Check if all 8 fields were parsed
                            // Basic validation (optional, but good practice)
                            if (l_yy >= 0 && l_yy <= 99 && l_MM >= 1 && l_MM <= 12 && l_dd >= 1 && l_dd <= 31 &&
                                l_hh >= 0 && l_hh <= 23 && l_mm >= 0 && l_mm <= 59 && l_ss >= 0 && l_ss <= 59 &&
                                (sign == '+' || sign == '-'))
                            {
                                year = 2000 + l_yy; // Assuming 21st century
                                month = l_MM;
                                day = l_dd;
                                hour = l_hh;
                                minute = l_mm;
                                second = l_ss;
                                timezoneOffsetQuarterHours = (sign == '+') ? l_zz : -l_zz;
                                timeValid = true;
                                lastTimeUpdateTime = std::chrono::steady_clock::now();
                                parsed_ok = true;
                                printf("[GSM Time] Updated: %04d/%02d/%02d %02d:%02d:%02d (Offset: %c%02d quarters)\n",
                                       year, month, day, hour, minute, second, sign, l_zz);
                            } else {
                                printf("[GSM Time] Parsed fields out of range: %s\n", time_str.c_str());
                            }
                        } else {
                            printf("[GSM Time] Failed to parse time string with sscanf (Fields read: %d): %s\n", fields_read, time_str.c_str());
                        }
                    } else {
                         printf("[GSM Time] Could not find quotes in +CCLK response.\n");
                    }
                } else {
                     printf("[GSM Time] +CCLK: not found in response.\n");
                }

                if (!parsed_ok) {
                    // Keep previous time? Or invalidate? Let's invalidate on parse failure.
                    // timeValid = false; // Uncomment if invalidation is desired on failure
                    printf("[GSM Time] Failed to update time.\n");
                }
                return false; // End of this command chain
            };
            // Use push_front to prioritize time sync if needed, or push_back for normal queueing
            // requests.insert(requests.begin(), request); // Prioritize
            requests.push_back(request); // Normal queue
        }

        // --- Public Time Functions ---
        void syncNetworkTime() {
            printf("[GSM Time] Queuing network time sync (AT+CCLK?).\n");
            updateTimeInternal();
        }

        int getYear() { return timeValid ? year : -1; }
        int getMonth() { return timeValid ? month : -1; }
        int getDay() { return timeValid ? day : -1; }
        int getHour() { return timeValid ? hour : -1; }
        int getMinute() { return timeValid ? minute : -1; }
        int getSecond() { return timeValid ? second : -1; }
        int getTimezoneOffsetQuarterHours() { return timeValid ? timezoneOffsetQuarterHours : 0; }
        bool isTimeValid() { return timeValid; }

    } // namespace Time


    // --- Internal Update Functions (Network, Voltage, etc.) ---

    // Enqueues a request to check AT+CSQ
    static void updateNetworkQualityInternal() {
        auto request = std::make_shared<Request>();
        request->command = "AT+CSQ";
        request->callback = [](const std::string& response) -> bool {
            int rssi = 99;
            int ber = 99;
            bool success = false;
            auto pos = response.find("+CSQ:");
            if (pos != std::string::npos) {
                std::string values = response.substr(pos + 5);
                std::stringstream ss(values);
                char comma;
                // Allow space before numbers
                ss >> std::ws >> rssi >> std::ws >> comma >> std::ws >> ber;
                if (!ss.fail() && comma == ',') {
                    success = true;
                }
            }
            if (success) {
                currentRssi = rssi;
                currentBer = ber;
                networkQualityValid = true;
                lastQualityUpdateTime = std::chrono::steady_clock::now();
                printf("[GSM State] Updated Network Quality: RSSI=%d, BER=%d\n", currentRssi, currentBer);
            } else {
                 networkQualityValid = false; // Invalidate on failure
                 printf("[GSM State] Failed to update Network Quality.\n");
            }
            return false; // End of this command chain
        };
        requests.push_back(request);
    }

    // Enqueues a request to check AT+CGATT?
    static void updateGprsAttachmentStatusInternal() {
        auto request = std::make_shared<Request>();
        request->command = "AT+CGATT?";
        request->callback = [](const std::string& response) -> bool {
            bool success = false;
            bool attached = false;
            auto pos = response.find("+CGATT:");
            if (pos != std::string::npos) {
                 std::string value_str = response.substr(pos + 7);
                 value_str.erase(0, value_str.find_first_not_of(" \t\r\n"));
                 if (!value_str.empty()) {
                     try {
                         int status = std::stoi(value_str);
                         attached = (status == 1);
                         success = true; // Successfully parsed the status line
                     } catch (...) {
                          printf("[GSM State] Failed to parse CGATT status value: %s\n", value_str.c_str());
                          success = false; // Parsing failed
                     }
                 } else { success = false; } // Empty value after colon
            } else if (response.find("OK") != std::string::npos && response.find("ERROR") == std::string::npos) {
                 // OK received, but no +CGATT line? Assume detached or error state.
                 // Let's treat this as state determined, but detached.
                 attached = false;
                 success = true; // Command finished, state known (as detached)
                 printf("[GSM State] GPRS Status: OK received but no +CGATT line. Assuming detached.\n");
            } else if (response.find("ERROR") != std::string::npos) {
                 // Expected without SIM or network
                 attached = false;
                 success = true; // Command completed (with error), state known (as detached)
                 printf("[GSM State] GPRS Status: Command Error (Expected without SIM/Network).\n");
            }

            if (success) {
                isGprsAttached = attached;
                gprsStateValid = true;
                lastGprsUpdateTime = std::chrono::steady_clock::now();
                printf("[GSM State] Updated GPRS Status: %s\n", isGprsAttached ? "Attached" : "Detached");
            } else {
                 gprsStateValid = false; // Invalidate on failure
                 printf("[GSM State] Failed to update GPRS Status.\n");
            }
            return false;
        };
        requests.push_back(request);
    }

    // Enqueues a request to check AT+CFUN?
    static void updateFlightModeStatusInternal() {
        auto request = std::make_shared<Request>();
        request->command = "AT+CFUN?";
        request->callback = [](const std::string& response) -> bool {
            bool success = false;
            bool flightMode = false; // true if RF is OFF
            auto pos = response.find("+CFUN:");
            if (pos != std::string::npos) {
                std::string value = response.substr(pos + 6);
                 value.erase(0, value.find_first_not_of(" \t\r\n"));
                 value.erase(value.find_last_not_of(" \t\r\n") + 1);
                try {
                    int funLevel = std::stoi(value);
                    // CFUN=4 is typically flight mode (RF OFF)
                    // CFUN=0 is minimum functionality (RF might be off)
                    // CFUN=1 is full functionality (RF ON)
                    if (funLevel == 4 || funLevel == 0) {
                        flightMode = true;
                    } else { // Assume funLevel == 1 or others mean RF ON
                        flightMode = false;
                    }
                    success = true;
                } catch (...) {
                     printf("[GSM State] Failed to parse CFUN level: %s\n", value.c_str());
                }
            }
            if (success) {
                flightModeState = flightMode;
                flightModeStateValid = true;
                lastFlightModeUpdateTime = std::chrono::steady_clock::now();
                printf("[GSM State] Updated Flight Mode Status: %s\n", flightModeState ? "ON (RF OFF)" : "OFF (RF ON)");
            } else {
                 flightModeStateValid = false; // Invalidate on failure
                 printf("[GSM State] Failed to update Flight Mode Status.\n");
            }
            return false;
        };
        requests.push_back(request);
    }

    // Enqueues a request to check AT+CBC (Handles simple and complex formats)
    static void updateVoltageInternal() {
        auto request = std::make_shared<Request>();
        request->command = "AT+CBC";
        request->callback = [](const std::string& response) -> bool {
            // --- Robust Parsing Logic ---
            std::stringstream ss_block(response);
            std::string line;
            bool found_cbc_line = false;
            bool parsed_value_ok = false;
            bool cmd_success = (response.find("OK") != std::string::npos);
            int voltage = -1; // Voltage in mV

            while (std::getline(ss_block, line, '\n')) {
                 // Trim line
                 if (!line.empty() && line.back() == '\r') line.pop_back();
                 line.erase(0, line.find_first_not_of(" \t"));
                 line.erase(line.find_last_not_of(" \t") + 1);

                 if (line.rfind("+CBC:", 0) == 0) {
                    found_cbc_line = true; // Found the line itself
                    std::string data_part = line.substr(5); // Get data after "+CBC:"
                    data_part.erase(0, data_part.find_first_not_of(" \t")); // Trim leading space

                    // --- Try parsing standard format first: <bcs>,<bcl>,<voltage> ---
                    size_t first_comma = data_part.find(',');
                    size_t second_comma = std::string::npos;
                    if (first_comma != std::string::npos) {
                        second_comma = data_part.find(',', first_comma + 1);
                    }

                    std::string voltage_str_raw;

                    if (first_comma != std::string::npos && second_comma != std::string::npos) {
                        // Assume complex format, extract voltage part after second comma
                        voltage_str_raw = data_part.substr(second_comma + 1);
                        // printf("[GSM State] Voltage: Trying complex parse (found commas).\n");
                    } else {
                        // Assume simple format (no commas found), treat the whole data_part as voltage
                        voltage_str_raw = data_part;
                        // printf("[GSM State] Voltage: Trying simple parse (no commas found).\n");
                    }

                    // Clean the extracted voltage string: remove non-digit characters
                    voltage_str_raw.erase(std::remove_if(voltage_str_raw.begin(), voltage_str_raw.end(),
                                                        [](char c) { return !std::isdigit(c); }),
                                        voltage_str_raw.end());

                    try {
                        if (!voltage_str_raw.empty()) {
                            voltage = std::stoi(voltage_str_raw); // Parse the cleaned voltage string
                            parsed_value_ok = true; // Mark value parsing as successful
                            // printf("[GSM State] Voltage Line Parsed: voltage=%d mV (Cleaned String: '%s', Original Data Part: '%s')\n",
                            //        voltage, voltage_str_raw.c_str(), data_part.c_str());
                        } else {
                             printf("[GSM State] Voltage Line Found but voltage string was empty after cleaning. (Original Data Part: '%s')\n", data_part.c_str());
                        }
                    } catch (const std::invalid_argument& ia) {
                        printf("[GSM State] Voltage Line Found but failed to parse numeric voltage value from cleaned string '%s' (Original Data Part: '%s')\n",
                               voltage_str_raw.c_str(), data_part.c_str());
                    } catch (const std::out_of_range& oor) {
                        printf("[GSM State] Voltage Line Found but numeric value out of range from cleaned string '%s' (Original Data Part: '%s')\n",
                               voltage_str_raw.c_str(), data_part.c_str());
                    }
                    break; // Found the +CBC line, processed (or failed), exit loop
                 }
            }
            // --- End Robust Parsing Logic ---

            bool update_successful = false;
            if (found_cbc_line && parsed_value_ok) { // Only update if line found AND value parsed
                currentVoltage_mV = voltage;

                try
                {
                    battery_voltage_history.push_back(currentVoltage_mV);
                    if (battery_voltage_history.size() > 24)
                        battery_voltage_history.erase(battery_voltage_history.begin());

                    if (battery_voltage_history.size() > 0) {
                        double sum = 0;
                        for (auto v : battery_voltage_history)
                            sum += v;
                            currentVoltage_mV = sum / battery_voltage_history.size();

                        std::cout << "[GSM State] Battery voltage average: " << voltage << std::endl;
                    }
                }
                catch (std::exception)
                {
                }

                voltageValid = true;
                lastVoltageUpdateTime = std::chrono::steady_clock::now();
                printf("[GSM State] Updated Voltage: %d mV\n", currentVoltage_mV);
                update_successful = true;
            } else if (!cmd_success && response.find("ERROR") != std::string::npos) {
                 printf("[GSM State] Voltage Update: Command Error received.\n");
            } else if (cmd_success && !found_cbc_line) {
                 printf("[GSM State] Voltage Update: OK received but +CBC line not found.\n");
            } else if (cmd_success && found_cbc_line && !parsed_value_ok) {
                 printf("[GSM State] Voltage Update: OK received, +CBC line found, but failed to parse voltage value.\n");
            } else if (!cmd_success && !found_cbc_line) {
                 printf("[GSM State] Voltage Update: Unexpected response state (No OK/ERROR/CBC).\n");
            }

            if (!update_successful) {
                 voltageValid = false; // Mark invalid on failure
                 printf("[GSM State] Failed to update Voltage state this cycle.\n");
            }
            return false; // End of this command chain
        };
        requests.push_back(request);
    }

    double getBatteryLevel() {
#ifdef ESP_PLATFORM
        if (currentVoltage_mV == -1) {
            // Probably return something else ?
            return 1;
        }

        // Thanks NumWorks for the regression app
        const double batteryLevel = 3.083368 * std::pow(currentVoltage_mV / 1000, 3) - 37.21203 * std::pow(currentVoltage_mV / 1000, 2) + 150.5735 * currentVoltage_mV / 1000 - 203.3347;

        //std::cout << "Battery level: " << batteryLevel << std::endl;

        return std::clamp(batteryLevel, 0.0, 1.0);

        // if (voltage > 4.12)
        //   return 100;
        // else if (voltage > 4.03)
        //     return 95;
        // else if (voltage > 3.99)
        //     return 90;
        // else if (voltage > 3.94)
        //     return 85;
        // else if (voltage > 3.90)
        //     return 80;
        // else if (voltage > 3.86)
        //     return 75;
        // else if (voltage > 3.82)
        //     return 70;
        // else if (voltage > 3.77)
        //     return 65;
        // else if (voltage > 3.74)
        //     return 60;
        // else if (voltage > 3.70)
        //     return 55;
        // else if (voltage > 3.66)
        //     return 50;
        // else if (voltage > 3.64)
        //     return 45;
        // else if (voltage > 3.63)
        //     return 40;
        // else if (voltage > 3.62)
        //     return 35;
        // else if (voltage > 3.59)
        //     return 30;
        // else if (voltage > 3.58)
        //     return 25;
        // else if (voltage > 3.57)
        //     return 20;
        // else if (voltage > 3.55)
        //     return 15;
        // else if (voltage > 3.52)
        //     return 10;
        // else if (voltage > 3.5)
        //     return 5;
        // else
        //     return 0;
#else
        return 1;
#endif
    }

    // Enqueues a request to check AT+CPIN?
    static void updatePinStatusInternal() {
        auto request = std::make_shared<Request>();
        request->command = "AT+CPIN?";
        request->callback = [](const std::string& response) -> bool {
            // --- Robust Parsing Logic ---
            std::stringstream ss_block(response);
            std::string line;
            std::string parsed_status = "";
            bool found_cpin_line = false;
            bool cmd_success = (response.find("OK") != std::string::npos);

            while (std::getline(ss_block, line, '\n')) {
                if (!line.empty() && line.back() == '\r') line.pop_back();
                line.erase(0, line.find_first_not_of(" \t"));
                line.erase(line.find_last_not_of(" \t") + 1);

                if (line.rfind("+CPIN:", 0) == 0) {
                    parsed_status = line.substr(6);
                    parsed_status.erase(0, parsed_status.find_first_not_of(" \t"));
                    parsed_status.erase(parsed_status.find_last_not_of(" \t") + 1);
                    found_cpin_line = true;
                    // printf("[GSM State] PIN Status Line Parsed: '%s'\n", parsed_status.c_str()); // Debug log
                    break;
                }
            }
            // --- End Robust Parsing Logic ---

            bool needsPin = true; // Default assumption
            bool status_determined = false;

            if (found_cpin_line) {
                if (parsed_status == "READY") {
                    needsPin = false;
                    status_determined = true;
                } else if (parsed_status == "SIM PIN" || parsed_status == "SIM PUK") {
                    needsPin = true;
                    status_determined = true;
                } else if (parsed_status == "NOT INSERTED" || parsed_status.find("NO SIM") != std::string::npos || parsed_status.find("NOT READY") != std::string::npos) {
                    needsPin = true; // Treat as requiring attention/no SIM
                    status_determined = true;
                    printf("[GSM State] PIN Status: SIM Not Inserted or Not Ready.\n");
                } else {
                    needsPin = true; // Default to required if unknown status
                    status_determined = true;
                    printf("[GSM State] PIN Status: Unknown Module Status (%s)\n", parsed_status.c_str());
                }
            } else if (!cmd_success && response.find("ERROR") != std::string::npos) {
                 printf("[GSM State] PIN Status: Command Error received.\n");
                 needsPin = true;
                 status_determined = false; // Status not determined due to error
            } else if (cmd_success && !found_cpin_line) {
                 printf("[GSM State] PIN Status: OK received but no +CPIN line found.\n");
                 needsPin = true; // Assume required
                 status_determined = false;
            } else {
                 printf("[GSM State] PIN Status: Unexpected response state.\n");
                 needsPin = true;
                 status_determined = false;
            }

            if (status_determined) {
                pinRequiresPin = needsPin;
                pinStatusValid = true;
                lastPinStatusUpdateTime = std::chrono::steady_clock::now();
                printf("[GSM State] Updated PIN Status: %s\n", pinRequiresPin ? "Required/Not Ready" : "Ready");
            } else {
                 pinStatusValid = false; // Mark as invalid if parsing/command failed
                 printf("[GSM State] Failed to update PIN Status (Parsing/Command Error or Unknown State).\n");
            }
            return false; // End of this command chain
        };
        requests.push_back(request);
    }

    // Enqueues a request to check AT+CMGF?
    static void updatePduModeStatusInternal() {
        auto request = std::make_shared<Request>();
        request->command = "AT+CMGF?";
        request->callback = [](const std::string& response) -> bool {
            bool success = false;
            bool pduMode = false; // Default to Text mode
            auto pos = response.find("+CMGF:");
            if (pos != std::string::npos) {
                std::string value = response.substr(pos + 6);
                 value.erase(0, value.find_first_not_of(" \t\r\n"));
                 value.erase(value.find_last_not_of(" \t\r\n") + 1);
                try {
                    int mode = std::stoi(value);
                    if (mode == 0) { // 0 = PDU Mode
                        pduMode = true;
                    } else { // 1 = Text Mode
                        pduMode = false;
                    }
                    success = true;
                } catch (...) {
                     printf("[GSM State] Failed to parse CMGF mode: %s\n", value.c_str());
                }
            }
            if (success) {
                pduModeEnabled = pduMode;
                pduModeStateValid = true;
                lastPduModeUpdateTime = std::chrono::steady_clock::now();
                printf("[GSM State] Updated PDU Mode Status: %s\n", pduModeEnabled ? "Enabled (0)" : "Disabled (1)");
            } else {
                 pduModeStateValid = false; // Invalidate on failure
                 printf("[GSM State] Failed to update PDU Mode Status.\n");
            }
            return false;
        };
        requests.push_back(request);
    }


    // --- Initialization ---
    void init()
    {
        #ifdef ESP_PLATFORM
        printf("[GSM] Initializing...\n");
        pinMode(GSM_PWR_PIN, OUTPUT);
        digitalWrite(GSM_PWR_PIN, 0); // Ensure power key is not asserted initially
        gsm.setRxBufferSize(4096); // Increase buffer size

        // Power Cycle Sequence (ensure module is likely off first)
        printf("[GSM] Ensuring module is off before power cycle...\n");
        digitalWrite(GSM_PWR_PIN, 1); // Pull PWRKEY HIGH (OFF state for many modules)
        delay(1500); // Hold high for >1s
        digitalWrite(GSM_PWR_PIN, 0); // Release PWRKEY
        delay(3000); // Wait for module to fully power down

        printf("[GSM] Powering on module...\n");
        digitalWrite(GSM_PWR_PIN, 1); // Pull PWRKEY HIGH to trigger power ON
        delay(1200); // Hold for typical power-on duration (check datasheet!)
        digitalWrite(GSM_PWR_PIN, 0); // Release PWRKEY
        printf("[GSM] Module power sequence complete. Waiting for boot (10s)...\n");
        delay(10000); // Generous wait time for module boot and network search


        bool comm_ok = false;
        int attempts = 0;
        const int max_attempts = 3; // Reduce attempts after forced power cycle

        // Try preferred baud rate first
        printf("[GSM] Attempting communication at 921600 bps...\n");
        gsm.begin(921600, SERIAL_8N1, RX, TX);
        delay(100); // Allow serial port to settle

        while(attempts < max_attempts && !comm_ok) {
            gsm.println("AT");
            delay(500); // Increased delay for response
            String data = "";
            while(gsm.available()) { data += (char)gsm.read(); } // Read full response
            Serial.print("[GSM RX @921600]: "); Serial.println(data);

            if (data.indexOf("OK") != -1) {
                printf("[GSM] Communication established at 921600 bps.\n");
                comm_ok = true;
            } else {
                printf("[GSM] No valid response at 921600. Retrying...\n");
                delay(2000); // Wait before retrying
            }
            attempts++;
        }

        // Fallback to 115200 if 921600 failed
        if (!comm_ok) {
            printf("[GSM] Failed at 921600. Trying 115200 bps...\n");
            gsm.updateBaudRate(115200); // Change ESP32 side baud rate
            delay(100);
            attempts = 0;
             while(attempts < max_attempts && !comm_ok) {
                gsm.println("AT");
                delay(500);
                String data = "";
                while(gsm.available()) { data += (char)gsm.read(); }
                Serial.print("[GSM RX @115200]: "); Serial.println(data);

                if (data.indexOf("OK") != -1) {
                    printf("[GSM] Communication established at 115200 bps. Setting preferred rate (921600)...\n");
                    gsm.println("AT+IPR=921600"); // Command module to change its baud rate
                    delay(100); gsm.flush(); // Wait for command to be sent
                    gsm.updateBaudRate(921600); // Change ESP32 side baud rate
                    delay(100);
                    // Verify communication at new rate
                    gsm.println("AT"); delay(500); data = ""; while(gsm.available()) { data += (char)gsm.read(); }
                    Serial.print("[GSM RX @921600]: "); Serial.println(data);
                    if (data.indexOf("OK") != -1) {
                         printf("[GSM] Communication verified at 921600.\n");
                         comm_ok = true;
                    } else {
                         printf("[GSM] Failed to verify communication after setting 921600. Sticking with 115200.\n");
                         // Revert ESP32 side back to 115200 if verification failed
                         gsm.updateBaudRate(115200);
                         delay(100);
                         // We know 115200 worked before the AT+IPR command
                         comm_ok = true; // Consider init successful at 115200
                    }
                } else {
                    printf("[GSM] No valid response at 115200. Retrying...\n");
                    delay(2000);
                }
                attempts++;
            }
        }


        if (comm_ok) {
             printf("[GSM] Module Initialized.\n");
             currentCallState = CallState::IDLE; // Set initial known state

             // --- Queue initial state updates ---
             printf("[GSM] Queuing initial state checks...\n");
             updatePinStatusInternal();        // Check SIM status first
             updateGprsAttachmentStatusInternal(); // Check GPRS status
             updateFlightModeStatusInternal();   // Check RF status
             updatePduModeStatusInternal();      // Check SMS mode
             updateNetworkQualityInternal();   // Check signal
             updateVoltageInternal();          // Check voltage
             Time::syncNetworkTime();          // Request initial time sync

             // Call uploadSettings to configure URCs etc.
             // Delay slightly before sending config commands
             delay(500);
             uploadSettings();
             return; // Success
        }

        printf("[GSM] Initialization failed after all attempts.\n");
        currentCallState = CallState::UNKNOWN; // Mark state as unknown on failure
        #else
        printf("[GSM] Dummy Init Completed.\n");
        currentCallState = CallState::IDLE;
        #endif
    }

    // Configure module settings (e.g., enable URCs)
    void uploadSettings()
    {
        printf("[GSM] Configuring module settings (URCs)...\n");

        // Enable Caller ID Notification (+CLIP)
        auto requestClip = std::make_shared<Request>();
        requestClip->command = "AT+CLIP=1";
        requestClip->callback = [](const std::string& response) -> bool {
            printf("[GSM Settings] CLIP %s.\n", (response.find("OK") != std::string::npos) ? "enabled" : "failed");
            return false;
        };
        requests.push_back(requestClip);

        // Enable Call Status Notification (+CLCC) - Useful for more detailed call state
        auto requestClcc = std::make_shared<Request>();
        requestClcc->command = "AT+CLCC=1";
        requestClcc->callback = [](const std::string& response) -> bool {
            printf("[GSM Settings] CLCC URC %s.\n", (response.find("OK") != std::string::npos) ? "enabled" : "failed");
            return false;
        };
        requests.push_back(requestClcc);

        // Configure SMS URCs (Example: +CMTI for indication)
        auto requestCnmi = std::make_shared<Request>();
        requestCnmi->command = "AT+CNMI=2,1,0,0,0"; // Mode 2 (buffer if DTR high), MT=1 (CMTI URC)
        requestCnmi->callback = [](const std::string& response) -> bool {
            printf("[GSM Settings] CNMI %s.\n", (response.find("OK") != std::string::npos) ? "configured" : "failed");
            return false;
        };
        requests.push_back(requestCnmi);

        // Enable Network Registration URCs (+CREG, +CGREG)
        auto requestCreg = std::make_shared<Request>();
        requestCreg->command = "AT+CREG=1"; // Basic URC
        requestCreg->callback = [](const std::string& response) -> bool {
             printf("[GSM Settings] CREG URC %s.\n", (response.find("OK") != std::string::npos) ? "enabled" : "failed");
             return false;
        };
        requests.push_back(requestCreg);

        auto requestCgreg = std::make_shared<Request>();
        requestCgreg->command = "AT+CGREG=1"; // Basic URC
        requestCgreg->callback = [](const std::string& response) -> bool {
             printf("[GSM Settings] CGREG URC %s.\n", (response.find("OK") != std::string::npos) ? "enabled" : "failed");
             // After enabling, trigger an update to get current status immediately
             if (response.find("OK") != std::string::npos) {
                 updateGprsAttachmentStatusInternal();
             }
             return false;
        };
        requests.push_back(requestCgreg);

        // Optional: Disable Echo (ATE0) - Can simplify parsing if echo is reliably off
        // auto requestEcho = std::make_shared<Request>();
        // requestEcho->command = "ATE0";
        // requestEcho->callback = [](const std::string& response) -> bool {
        //      printf("[GSM Settings] Echo %s.\n", (response.find("OK") != std::string::npos) ? "disabled (ATE0)" : "disable failed");
        //      return false;
        // };
        // requests.push_back(requestEcho);
    }

    // --- Response/URC Identification ---
    bool isEndIdentifier(const std::string& data) {
        // Standard final replies
        if (data == "OK" || data == "ERROR" || data == "NO CARRIER" ||
            data == "BUSY" || data == "NO ANSWER" || data == "NO DIALTONE") return true;
        // Error code replies
        if (data.rfind("+CME ERROR:", 0) == 0 || data.rfind("+CMS ERROR:", 0) == 0) return true;
        return false;
    }

    const std::vector<std::string> known_urc_prefixes = {
        "RING",             // Incoming call indication
        "+CLIP:",           // Calling line identification
        "+CLCC:",           // Call list URC (if AT+CLCC=1 enabled)
        "NO CARRIER",       // Call terminated / GPRS disconnected (Can be response OR URC)
        "BUSY",             // Called party busy (Can be response OR URC)
        "NO ANSWER",        // Called party did not answer (Can be response OR URC)
        "+CMTI:",           // New SMS message indication
        "+CMT:",            // New SMS message content
        "+CBM:",            // New cell broadcast message
        "+CDS:",            // SMS status report
        "+CREG:",           // Network registration status change
        "+CGREG:",          // GPRS registration status change
        "+CEREG:",          // EPS (LTE) registration status change
        "+PDP:",            // PDP context activated/deactivated
        "+SAPBR:",          // Bearer status change
        // "+CPIN:",        // REMOVED - Treat as command response first
        "Call Ready",       // Module ready for calls
        "SMS Ready",        // Module ready for SMS
        "NORMAL POWER DOWN",// Module shutting down normally
        "UNDER-VOLTAGE WARNING",
        "UNDER-VOLTAGE POWER DOWN",
        "+SIMREADY",        // SIM card fully initialized
        // Socket related URCs
        "+RECEIVE",
        "CLOSED",
        "REMOTE IP:",
        "+IP_INITIAL",
        "+IP_STATUS",
        "+PDP_DEACT",
        "+SAPBR_DEACT",
        // Location URCs
        "+LOCATION:",
        "+CIPGSMLOC:",
        // HTTP/FTP URCs
        "+HTTPACTION:",
        "+FTPGET:",
        "+CGEV:"            // EPS (LTE/GPRS) event report URC
    };

    bool isURC(const std::string& data) {
        if (data.empty()) return false;
        for (const std::string& prefix : known_urc_prefixes) {
            // Use find instead of rfind for prefix check
            if (data.find(prefix) == 0) return true;
            // Handle cases like "+CME ERROR:" which are end identifiers but start like URCs
            // Let isEndIdentifier handle these specific error codes.
        }
        // Special case: "+CPIN:" might be an URC if SIM is removed/inserted *unsolicitedly*
        // But we removed it from the main list to avoid conflict with AT+CPIN? response.
        // If needed, add specific logic here or in processURC to handle unsolicited +CPIN.
        return false;
    }

    // --- URC Processing (Updates Internal State) ---
    void processURC(std::string data)
    {
        printf("[GSM URC]: %s\n", data.c_str());

        // --- Call Related URCs ---
        if (data.find("RING") == 0) {
            currentCallState = CallState::RINGING;
            lastIncomingCallNumber = ""; // Clear previous number on new RING
        } else if (data.find("+CLIP:") == 0) {
            size_t firstQuote = data.find('"');
            size_t secondQuote = data.find('"', firstQuote + 1);
            if (firstQuote != std::string::npos && secondQuote != std::string::npos) {
                lastIncomingCallNumber = data.substr(firstQuote + 1, secondQuote - firstQuote - 1);
                printf("[GSM State] Incoming call from: %s\n", lastIncomingCallNumber.c_str());
                // Ensure state is RINGING if CLIP arrives
                if(currentCallState != CallState::RINGING) {
                    currentCallState = CallState::RINGING;
                }
            }
        } else if (data.find("+CLCC:") == 0) {
            // Parse call state from +CLCC URC (if AT+CLCC=1 is enabled)
            // Format: +CLCC: <id>,<dir>,<stat>,<mode>,<mpty>[,<number>,<type>]
            std::stringstream ss_clcc(data.substr(6)); // Skip "+CLCC: "
            std::string clcc_part;
            std::vector<std::string> clcc_parts;
            while(std::getline(ss_clcc, clcc_part, ',')) { clcc_parts.push_back(clcc_part); }

            if (clcc_parts.size() >= 3) {
                try {
                    int stat = std::stoi(clcc_parts[2]);
                    CallState previousState = currentCallState;
                    switch(stat) {
                        case 0: currentCallState = CallState::ACTIVE; break; // Active
                        case 1: break; // Held (ignore for now or map to ACTIVE?)
                        case 2: currentCallState = CallState::DIALING; break; // Dialing (MO)
                        case 3: currentCallState = CallState::DIALING; break; // Alerting (MO)
                        case 4: currentCallState = CallState::RINGING; break; // Incoming (MT)
                        case 5: break; // Waiting (MT) (ignore for now or map to RINGING?)
                        case 6: currentCallState = CallState::IDLE; break; // Disconnect initiated by us? Or call ended. Safer to set IDLE.
                        default: break; // Unknown state
                    }
                     if (currentCallState != previousState) {
                        printf("[GSM State] Call state updated via CLCC: %d -> %d\n", static_cast<int>(previousState), static_cast<int>(currentCallState));
                        if (currentCallState == CallState::IDLE) {
                            lastIncomingCallNumber = ""; // Clear number when call ends
                        }
                     }
                } catch (...) { printf("[GSM URC] Failed to parse CLCC status.\n"); }
            }
             // If the URC is just "+CLCC:" with nothing after, it might indicate no active calls.
             // This depends heavily on the module. Relying on NO CARRIER or state 6 is safer.
             if (data == "+CLCC:") { // Check specific module behavior
                 if (currentCallState != CallState::IDLE) {
                     printf("[GSM State] Empty +CLCC URC received, assuming IDLE.\n");
                     currentCallState = CallState::IDLE;
                     lastIncomingCallNumber = "";
                 }
             }

        } else if (data == "NO CARRIER" || data == "BUSY" || data == "NO ANSWER") {
            // These often signify the end of a call attempt or active call
            if (currentCallState != CallState::IDLE) {
                 printf("[GSM State] Call terminated/failed URC (%s). Setting state to IDLE.\n", data.c_str());
                 currentCallState = CallState::IDLE;
                 lastIncomingCallNumber = "";
            }
        }
        // --- SMS Related URCs ---
        else if (data.find("+CMTI:") == 0) {
            printf("[GSM URC] New SMS received indication: %s\n", data.c_str());
            // Application layer should handle reading based on this indication
        }
        // --- Network/Status URCs ---
        else if (data.find("+CREG:") == 0 || data.find("+CGREG:") == 0) {
            printf("[GSM URC] Network registration URC: %s\n", data.c_str());
            // Parse status if needed, e.g., +CGREG: <n>,<stat>[,<lac>,<ci>]
            size_t comma_pos = data.find(',');
            if (comma_pos != std::string::npos) {
                try {
                    // Extract status part, removing potential leading space after comma
                    std::string stat_str = data.substr(comma_pos + 1);
                    size_t next_comma = stat_str.find(',');
                    if(next_comma != std::string::npos) { stat_str = stat_str.substr(0, next_comma); }
                    stat_str.erase(0, stat_str.find_first_not_of(" \t"));

                    int stat = std::stoi(stat_str);
                    bool attached = (stat == 1 || stat == 5); // 1=Home, 5=Roaming

                    if (data.find("+CGREG:") == 0) { // Only update GPRS state from CGREG
                        if (!gprsStateValid || isGprsAttached != attached) {
                             printf("[GSM State] GPRS state updated via URC: %s (Stat=%d)\n", attached ? "Attached" : "Detached", stat);
                             isGprsAttached = attached;
                             gprsStateValid = true; // URC confirms validity
                             lastGprsUpdateTime = std::chrono::steady_clock::now();
                        }
                    }
                    // Could update a separate CREG status variable if needed for circuit-switched status
                } catch (...) { printf("[GSM URC] Failed to parse REG status.\n"); }
            }
        }
        // Note: Unsolicited +CPIN handling removed from here as it's not in known_urc_prefixes
        else if (data == "Call Ready" || data == "SMS Ready" || data == "+SIMREADY") {
            printf("[GSM URC] Module Ready URC: %s\n", data.c_str());
            if (currentCallState == CallState::UNKNOWN) {
                currentCallState = CallState::IDLE;
            }
            // Could trigger initial state checks again if needed, e.g., if SIM was just read
            if (!pinStatusValid) {
                updatePinStatusInternal();
            }
        }
        else if (data.find("+CGEV:") == 0) {
             printf("[GSM URC] GPRS/EPS Event: %s\n", data.c_str());
             // Example: +CGEV: NW DETACH / EPS DETACH -> GPRS detached
             // Example: +CGEV: ME PDN ACT <cid> -> GPRS attached (potentially)
             // Add logic here if specific CGEV events need to update state
             if (data.find("DETACH") != std::string::npos) {
                 if (isGprsAttached) {
                     printf("[GSM State] GPRS detached via CGEV URC.\n");
                     isGprsAttached = false;
                     gprsStateValid = true; // URC confirms validity
                     lastGprsUpdateTime = std::chrono::steady_clock::now();
                 }
             }
             // Note: PDN ACT might not directly mean usable internet, just that a context is active.
             // Relying on AT+CGATT? or CGREG URC is often more reliable for general "connected" state.
        }
        // Add processing for other relevant URCs here...
    }


    // --- Public Accessors (Getters) ---

    std::pair<int, int> getNetworkQuality() { return {currentRssi, currentBer}; }
    bool isNetworkQualityValid() { return networkQualityValid; }

    bool isConnected() { return isGprsAttached; }
    bool isConnectedStateValid() { return gprsStateValid; }

    bool isFlightModeActive() { return flightModeState; }
    bool isFlightModeStateValid() { return flightModeStateValid; }

    int getVoltage() { return currentVoltage_mV; }
    bool isVoltageValid() { return voltageValid; }

    bool isPinRequired() { return pinRequiresPin; }
    bool isPinStatusValid() { return pinStatusValid; }

    bool isPduModeEnabled() { return pduModeEnabled; }
    bool isPduModeStateValid() { return pduModeStateValid; }

    CallState getCallState() { return currentCallState; }

    std::string getLastIncomingNumber() { return lastIncomingCallNumber; }


    // --- Public Action Functions ---

    void setPin(const std::string& pin, std::function<void(bool success)> completionCallback) {
        auto request = std::make_shared<Request>();
        request->command = "AT+CPIN=" + pin;
        request->callback = [completionCallback](const std::string& response) -> bool {
            bool success = (response.find("OK") != std::string::npos);
            printf("[GSM Action] setPin %s.\n", success ? "succeeded" : "failed");
            if (success) {
                // Update internal state optimistically and trigger a refresh to confirm
                pinRequiresPin = false;
                pinStatusValid = true; // Assume valid after successful set
                lastPinStatusUpdateTime = std::chrono::steady_clock::now();
                updatePinStatusInternal(); // Enqueue a check to be sure
            }
            if (completionCallback) {
                completionCallback(success);
            }
            return false;
        };
        requests.push_back(request);
    }

    void setFlightMode(bool enableFlightMode, std::function<void(bool success)> completionCallback) {
        auto request = std::make_shared<Request>();
        // Use CFUN=4 for Flight Mode (RF OFF), CFUN=1 for Full Functionality (RF ON)
        request->command = "AT+CFUN=" + std::string(enableFlightMode ? "4" : "1");
        request->callback = [completionCallback, enableFlightMode](const std::string& response) -> bool {
            // Some modules take time for CFUN change, OK might be immediate but state change delayed.
            // Response "OK" means command accepted, not necessarily completed.
            bool success = (response.find("OK") != std::string::npos);
             printf("[GSM Action] setFlightMode(%s) command %s.\n", enableFlightMode ? "ON" : "OFF", success ? "accepted" : "rejected");
            if (success) {
                // Update internal state optimistically or trigger a refresh after a delay
                flightModeState = enableFlightMode;
                flightModeStateValid = true; // Assume valid for now
                lastFlightModeUpdateTime = std::chrono::steady_clock::now();
                // Consider adding a delayed refresh:
                // PaxOS_StartDelayed(2000, [](){ updateFlightModeStatusInternal(); }); // Example
            }
            if (completionCallback) {
                completionCallback(success); // Reports command acceptance
            }
            return false;
        };
        requests.push_back(request);
    }

     void setPduMode(bool enablePdu, std::function<void(bool success)> completionCallback) {
        auto request = std::make_shared<Request>();
        request->command = "AT+CMGF=" + std::string(enablePdu ? "0" : "1");
        request->callback = [completionCallback, enablePdu](const std::string& response) -> bool {
            bool success = (response.find("OK") != std::string::npos);
            printf("[GSM Action] setPduMode(%s) %s.\n", enablePdu ? "PDU" : "Text", success ? "succeeded" : "failed");
             if (success) {
                pduModeEnabled = enablePdu;
                pduModeStateValid = true;
                lastPduModeUpdateTime = std::chrono::steady_clock::now();
             }
            if (completionCallback) {
                completionCallback(success);
            }
            return false;
        };
        requests.push_back(request);
    }

    void sendMessagePDU(const std::string& pdu, int length, std::function<void(bool success, int messageRef)> completionCallback) {
        // --- Request 1: Send AT+CMGS=<length> ---
        auto request1 = std::make_shared<Request>();
        request1->command = "AT+CMGS=" + std::to_string(length);

        // --- Request 2: Send PDU + Ctrl+Z ---
        auto request2 = std::make_shared<Request>();
        // IMPORTANT: Do not add \r or \n after Ctrl+Z for PDU sending
        request2->command = pdu + "\x1A";

        // --- Callback for Request 1 (Checks for '>') ---
        request1->callback = [completionCallback](const std::string& response) -> bool {
            // Check if the response *ends* with '>' possibly preceded by whitespace/CR/LF
            std::string trimmed_response = response;
            size_t last_char_pos = trimmed_response.find_last_not_of(" \t\r\n");
            if (last_char_pos != std::string::npos && trimmed_response[last_char_pos] == '>') {
                printf("[GSM Action] PDU prompt received.\n");
                return true; // Proceed to send PDU data (request2)
            } else {
                printf("[GSM Action] Failed to get PDU prompt '>'. Response block:\n%s---\n", response.c_str());
                if (completionCallback) completionCallback(false, -1);
                return false; // Stop chain
            }
        };

        // --- Callback for Request 2 (Checks for +CMGS: <mr> and OK) ---
        request2->callback = [completionCallback](const std::string& response) -> bool {
            int messageRef = -1;
            bool success = false;
            auto pos = response.find("+CMGS:");
            if (pos != std::string::npos) {
                std::string mr_str = response.substr(pos + 6);
                // Extract only the number part
                 size_t first_digit = mr_str.find_first_of("0123456789");
                 size_t last_digit = mr_str.find_first_not_of("0123456789", first_digit);
                 if (first_digit != std::string::npos) {
                     mr_str = mr_str.substr(first_digit, last_digit == std::string::npos ? std::string::npos : last_digit - first_digit);
                     try { messageRef = std::stoi(mr_str); } catch (...) { /* ignore parse error */ }
                 }
                // Check for OK as well, as it should follow +CMGS:
                if (response.find("OK") != std::string::npos) {
                    success = true;
                } else {
                     printf("[GSM Action] +CMGS found but no OK received.\n");
                }
            } else if (response.find("OK") != std::string::npos) {
                 // OK without +CMGS? Shouldn't happen for successful send. Treat as failure?
                 printf("[GSM Action] OK received without +CMGS reference.\n");
                 success = false; // Or maybe true depending on module? Let's assume false.
            } else if (response.find("ERROR") != std::string::npos) {
                 success = false;
            }

            printf("[GSM Action] sendMessagePDU %s (MR: %d).\n", success ? "succeeded" : "failed", messageRef);
            if (completionCallback) {
                completionCallback(success, messageRef);
            }
            return false; // End of chain
        };

        request1->next = request2; // Link requests
        requests.push_back(request1); // Enqueue first request
    }

    // --- PDU Encoding Implementation ---

    // Helper to convert a byte (unsigned char) to a 2-char hex string
    static std::string byteToHex(unsigned char byte) {
        std::stringstream ss;
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
        return ss.str();
    }

    // Helper to encode the phone number in semi-octet format
    // Returns the encoded string (e.g., "12345" -> "2143F5")
    static std::string encodePhoneNumber(const std::string& number) {
        std::string encoded;
        int len = number.length();
        for (int i = 0; i < len; i += 2) {
            if (i + 1 < len) {
                encoded += number[i + 1];
                encoded += number[i];
            } else {
                // Odd length number, pad with 'F'
                encoded += 'F';
                encoded += number[i];
            }
        }
        return encoded;
    }

    // Helper to pack 7-bit ASCII characters into octets for PDU user data
    // Handles basic GSM 7-bit default alphabet characters (@ maps to 0x00)
    static std::string pack7Bit(const std::string& message, int& septetCount) {
        std::string packedData;
        unsigned char buffer = 0;
        int bitsInBuff = 0;
        septetCount = 0;

        for (char c : message) {
            unsigned char septet;
            // Basic GSM 7-bit mapping (add more if needed)
            if (c == '@') {
                septet = 0x00;
            } else if (c >= 'a' && c <= 'z') {
                septet = c; // Lowercase maps directly in basic set
            } else if (c >= 'A' && c <= 'Z') {
                septet = c; // Uppercase maps directly
            } else if (c >= '0' && c <= '9') {
                septet = c; // Digits map directly
            } else {
                // Map other common characters (incomplete list!)
                switch (c) {
                    case ' ': septet = 0x20; break;
                    case '!': septet = 0x21; break;
                    case '"': septet = 0x22; break;
                    case '#': septet = 0x23; break;
                    case '$': septet = 0x02; break; // Note: $ maps differently
                    case '%': septet = 0x25; break;
                    case '&': septet = 0x26; break;
                    case '\'': septet = 0x27; break;
                    case '(': septet = 0x28; break;
                    case ')': septet = 0x29; break;
                    case '*': septet = 0x2A; break;
                    case '+': septet = 0x2B; break;
                    case ',': septet = 0x2C; break;
                    case '-': septet = 0x2D; break;
                    case '.': septet = 0x2E; break;
                    case '/': septet = 0x2F; break;
                    case ':': septet = 0x3A; break;
                    case ';': septet = 0x3B; break;
                    case '<': septet = 0x3C; break;
                    case '=': septet = 0x3D; break;
                    case '>': septet = 0x3E; break;
                    case '?': septet = 0x3F; break;
                    case '_': septet = 0x11; break; // Note: _ maps differently
                    case '\n': septet = 0x0A; break; // LF
                    case '\r': septet = 0x0D; break; // CR
                    // Add mappings for , , , , , etc. if needed
                    // Using the 0x1B escape for extended table is more complex
                    default: septet = 0x3F; break; // Replace unknown chars with '?'
                }
            }

            // Ensure septet is 7 bits
            septet &= 0x7F;

            // Pack the 7-bit character into octets
            buffer |= (septet << bitsInBuff);
            bitsInBuff += 7;

            // Extract full octets from the buffer
            // The lowest 'bitsInBuff % 8' bits of the *current* septet
            // form the most significant bits of the output octet.
            // The highest '8 - (bitsInBuff % 8)' bits of the *previous* septet's
            // remainder form the least significant bits.

            // Simpler logic: Process based on septet index
            int shift = septetCount % 8; // How many bits of this septet go into the *next* octet
            unsigned char octet = (buffer >> (7 - shift)); // Get bits for the *current* octet

            packedData += byteToHex(octet);

            buffer = septet; // Keep the current septet for the next round
            bitsInBuff = shift; // Bits remaining from current septet

            septetCount++;
        }

        // No need to handle remaining buffer bits for standard 7-bit packing,
        // the UDL tells the receiver how many septets to decode.

        // Correction in packing logic: Let's use a more standard algorithm.
        packedData = ""; // Reset packed data
        septetCount = 0;
        int bit_offset = 0; // Tracks the current bit position within the output octet stream

        for (char c_char : message) {
             unsigned char septet;
             // Remap character to 7-bit GSM alphabet value (same mapping as above)
             if (c_char == '@') septet = 0x00;
             else if (c_char >= 'a' && c_char <= 'z') septet = c_char;
             else if (c_char >= 'A' && c_char <= 'Z') septet = c_char;
             else if (c_char >= '0' && c_char <= '9') septet = c_char;
             else { /* ... rest of switch statement ... */
                 switch (c_char) {
                    case ' ': septet = 0x20; break; case '!': septet = 0x21; break;
                    case '"': septet = 0x22; break; case '#': septet = 0x23; break;
                    case '$': septet = 0x02; break; case '%': septet = 0x25; break;
                    case '&': septet = 0x26; break; case '\'': septet = 0x27; break;
                    case '(': septet = 0x28; break; case ')': septet = 0x29; break;
                    case '*': septet = 0x2A; break; case '+': septet = 0x2B; break;
                    case ',': septet = 0x2C; break; case '-': septet = 0x2D; break;
                    case '.': septet = 0x2E; break; case '/': septet = 0x2F; break;
                    case ':': septet = 0x3A; break; case ';': septet = 0x3B; break;
                    case '<': septet = 0x3C; break; case '=': septet = 0x3D; break;
                    case '>': septet = 0x3E; break; case '?': septet = 0x3F; break;
                    case '_': septet = 0x11; break; case '\n': septet = 0x0A; break;
                    case '\r': septet = 0x0D; break; default: septet = 0x3F; break;
                 }
             }
             septet &= 0x7F;
             septetCount++;

             int octet_index = bit_offset / 8; // Index of the current octet being built
             int bit_index = bit_offset % 8;   // Bit position within the current octet

             // Ensure packedData string is long enough (2 chars per octet)
             if (packedData.length() < (octet_index + 1) * 2) {
                 packedData.resize((octet_index + 1) * 2, '0'); // Initialize with '0'
             }

             // Convert hex chars back to byte value if needed
             unsigned char current_octet_val = 0;
             if (bit_index != 0) { // Only read if not the start of a new octet
                try {
                    current_octet_val = static_cast<unsigned char>(std::stoi(packedData.substr(octet_index * 2, 2), nullptr, 16));
                } catch(...) { /* handle error or ignore */ }
             }

             // Place the bits of the septet into the octet stream
             // Lower (7 - bit_index) bits of septet go into the current octet
             current_octet_val |= (septet << bit_index);
             packedData.replace(octet_index * 2, 2, byteToHex(current_octet_val));

             // If septet crosses octet boundary
             if (bit_index > 1) { // (7 + bit_index) > 8
                 // Ensure next octet exists
                 if (packedData.length() < (octet_index + 2) * 2) {
                     packedData.resize((octet_index + 2) * 2, '0');
                 }
                 unsigned char next_octet_val = 0;
                 // Higher (bit_index - 1) bits go into the next octet
                 next_octet_val |= (septet >> (8 - bit_index));
                 packedData.replace((octet_index + 1) * 2, 2, byteToHex(next_octet_val));
             }

             bit_offset += 7; // Advance bit counter
        }


        return packedData;
    }


    // Main PDU Encoder Function (SMS-SUBMIT)
    std::pair<std::string, int> encodePduSubmit(const std::string& recipientNumber, const std::string& message) {
        std::string pdu = "";
        int cmgsLength = 0;

        // --- 1. Service Center Address (SCA) ---
        // Using "00" tells the modem to use its default stored SCA.
        // The length byte "00" itself is part of the SCA field.
        pdu += "00";
        // Note: SCA is NOT included in the length for AT+CMGS

        // --- 2. PDU Type (First Octet of TPDU) ---
        // TP-MTI: 01 (SMS-SUBMIT)
        // TP-RD:  0  (Accept duplicates)
        // TP-VPF: 00 (No Validity Period field)
        // TP-SRR: 0  (No Status Report Request)
        // TP-UDHI:0  (User Data Header Indicator = false)
        // TP-RP:  0  (Reply Path = false)
        // Result: 00000001 = 0x01
        pdu += "01";
        cmgsLength++;

        // --- 3. TP-Message-Reference (TP-MR) ---
        // Set by the ME, just use 00 as placeholder. Modem will assign actual reference.
        pdu += "00";
        cmgsLength++;

        // --- 4. TP-Destination-Address (TP-DA) ---
        std::string cleanNumber = recipientNumber;
        // Remove '+' if present, assume international format if it was there
        bool isInternational = false;
        if (!cleanNumber.empty() && cleanNumber[0] == '+') {
            isInternational = true;
            cleanNumber = cleanNumber.substr(1);
        }
        // Remove any other non-digits (optional, depends on required input format)
        cleanNumber.erase(std::remove_if(cleanNumber.begin(), cleanNumber.end(),
                                         [](char c){ return !std::isdigit(c); }),
                          cleanNumber.end());

        if (cleanNumber.empty()) {
            printf("[PDU Encode] Error: Recipient number is empty or invalid.\n");
            return {"", -1}; // Return error
        }

        // Length of the number (number of digits)
        pdu += byteToHex(static_cast<unsigned char>(cleanNumber.length()));
        cmgsLength++;

        // Type-of-Address (TOA)
        // 91 = International format (includes '+')
        // 81 = National/Unknown format
        pdu += (isInternational ? "91" : "81");
        cmgsLength++;

        // Encoded phone number (semi-octets)
        std::string encodedNumber = encodePhoneNumber(cleanNumber);
        pdu += encodedNumber;
        cmgsLength += encodedNumber.length() / 2; // Each pair of hex chars is one octet

        // --- 5. TP-Protocol-Identifier (TP-PID) ---
        // 0x00 for standard SMS
        pdu += "00";
        cmgsLength++;

        // --- 6. TP-Data-Coding-Scheme (TP-DCS) ---
        // 0x00 for GSM 7-bit default alphabet, no message class
        pdu += "00";
        cmgsLength++;

        // --- 7. TP-Validity-Period (TP-VP) ---
        // Omitted as TP-VPF = 00 in PDU Type field

        // --- 8. TP-User-Data-Length (TP-UDL) ---
        // Length of the message in *septets* (7-bit characters)
        int septetCount = 0; // This will be calculated by pack7Bit
        std::string packedUserData = pack7Bit(message, septetCount);

        // Check message length limit (optional, 160 for single 7-bit SMS)
        if (septetCount > 160) {
             printf("[PDU Encode] Warning: Message length (%d septets) exceeds 160. May be split or fail.\n", septetCount);
             // Truncate if desired:
             // message = message.substr(0, 160);
             // packedUserData = pack7Bit(message, septetCount); // Re-pack truncated message
        }

        pdu += byteToHex(static_cast<unsigned char>(septetCount));
        cmgsLength++;

        // --- 9. TP-User-Data (TP-UD) ---
        pdu += packedUserData;
        // Length calculation for packed data is tricky, it's the number of octets used.
        // cmgsLength += packedUserData.length() / 2; // This is correct if pack7Bit returns hex string
        // Or calculate based on septets: ceil(septetCount * 7.0 / 8.0)
        cmgsLength += static_cast<int>(std::ceil(septetCount * 7.0 / 8.0));


        // Convert PDU to uppercase hex (often expected by modems)
        std::transform(pdu.begin(), pdu.end(), pdu.begin(), ::toupper);

        return {pdu, cmgsLength};
    }


    void sendMySms(const std::string& recipient, const std::string& text) {
        // 1. Encode the message
        std::pair<std::string, int> pduData = Gsm::encodePduSubmit(recipient, text);

        if (pduData.second == -1) {
            printf("[SMS Example] Failed to encode PDU for SMS.\n");
            return;
        }

        std::string pduString = pduData.first;
        int cmgsLength = pduData.second;

        printf("[SMS Example] PDU to send: %s\n", pduString.c_str());
        printf("[SMS Example] Length for AT+CMGS: %d\n", cmgsLength);

        // 2. Ensure PDU mode is set (can be done once at init or checked here)
        // Gsm::setPduMode(true, [](bool success){ /* handle callback */ });
        // Need to wait for setPduMode to complete if called here. Better to set at init.

        // 3. Send the PDU using the existing Gsm::sendMessagePDU function
        Gsm::sendMessagePDU(pduString, cmgsLength, [](bool success, int messageRef) {
            if (success) {
                printf("[SMS Example] SMS sent successfully! Message Reference: %d\n", messageRef);
            } else {
                printf("[SMS Example] Failed to send SMS.\n");
            }
        });
    }

    

    void call(const std::string& number, std::function<void(bool success)> completionCallback) {
        if (currentCallState != CallState::IDLE) {
            printf("[GSM Action] Cannot call, state is not IDLE (%d).\n", static_cast<int>(currentCallState));
            if (completionCallback) completionCallback(false);
            return;
        }
        auto request = std::make_shared<Request>();
        request->command = "ATD" + number + ";"; // Semicolon for voice call
        request->callback = [completionCallback, number](const std::string& response) -> bool {
            // Success is just command acceptance (OK). Actual call progress via URCs.
            bool success = (response.find("OK") != std::string::npos);
            printf("[GSM Action] call(%s) command %s.\n", number.c_str(), success ? "accepted" : "rejected");
            if (success) {
                currentCallState = CallState::DIALING; // Update state immediately
            }
            if (completionCallback) {
                completionCallback(success); // Report command acceptance
            }
            return false;
        };
        requests.push_back(request);
    }

    void acceptCall(std::function<void(bool success)> completionCallback) {
         if (currentCallState != CallState::RINGING) {
             printf("[GSM Action] Cannot accept call, state is not RINGING (%d).\n", static_cast<int>(currentCallState));
            if (completionCallback) completionCallback(false);
            return;
        }
        auto request = std::make_shared<Request>();
        request->command = "ATA";
        request->callback = [completionCallback](const std::string& response) -> bool {
            bool success = (response.find("OK") != std::string::npos);
            printf("[GSM Action] acceptCall command %s.\n", success ? "accepted" : "rejected");
            if (success) {
                currentCallState = CallState::ACTIVE; // Update state immediately
            } else {
                 // If ATA fails, module might still be RINGING or go IDLE.
                 // Rely on URCs (+CLCC, NO CARRIER) to confirm state.
                 printf("[GSM Action] ATA command failed. Call state might be inconsistent.\n");
            }
            if (completionCallback) {
                completionCallback(success); // Report command acceptance
            }
            return false;
        };
        requests.push_back(request);
    }

    void rejectCall(std::function<void(bool success)> completionCallback) {
         // Can reject RINGING call or hang up DIALING/ACTIVE call
         if (currentCallState == CallState::IDLE || currentCallState == CallState::UNKNOWN) {
             printf("[GSM Action] Cannot reject/hangup, no call active/ringing/dialing (%d).\n", static_cast<int>(currentCallState));
            if (completionCallback) completionCallback(false);
            return;
        }
        auto request = std::make_shared<Request>();
        // ATH is standard hang-up. Some modules use AT+CHUP. ATH is more common.
        request->command = "ATH";
        request->callback = [completionCallback](const std::string& response) -> bool {
            bool success = (response.find("OK") != std::string::npos);
             printf("[GSM Action] rejectCall/hangup command %s.\n", success ? "accepted" : "rejected");
            if (success) {
                // Update state immediately. URC (NO CARRIER / +CLCC: 6) should follow to confirm.
                currentCallState = CallState::IDLE;
                lastIncomingCallNumber = "";
            } else {
                 printf("[GSM Action] ATH command failed. Call state might be inconsistent.\n");
            }
            if (completionCallback) {
                completionCallback(success); // Report command acceptance
            }
            return false;
        };
        requests.push_back(request);
    }

    // --- Public Refresh Functions ---
    void refreshNetworkQuality() { updateNetworkQualityInternal(); }
    void refreshConnectionStatus() { updateGprsAttachmentStatusInternal(); }
    void refreshFlightModeStatus() { updateFlightModeStatusInternal(); }
    void refreshVoltage() { updateVoltageInternal(); }
    void refreshPinStatus() { updatePinStatusInternal(); }
    void refreshPduModeStatus() { updatePduModeStatusInternal(); }
    // Time refresh is done via Gsm::Time::syncNetworkTime()


    // --- Main Processing Loop (run) ---
    void run()
    {
        enum class SerialRunState { NO_COMMAND, COMMAND_RUNNING, SENDING_PDU_DATA };
        static SerialRunState state = SerialRunState::NO_COMMAND;
        static std::chrono::steady_clock::time_point lastCommandTime;
        // Adjust timeout based on command? Some commands take longer (e.g., network scan)
        const std::chrono::milliseconds commandTimeoutDuration(15000); // 15s default timeout
        const std::chrono::milliseconds pduTimeoutDuration(30000); // Longer timeout for SMS sending

        static std::string currentResponseBlock = ""; // Accumulates response lines
        static std::string lineBuffer = ""; // Handles partial lines from serial read

        // --- Periodic State Updates ---
        // Handled by eventHandlerBack in loop() now

        // --- Command Sending ---
        if (state == SerialRunState::NO_COMMAND && !requests.empty())
        {
            currentRequest = requests.front();
            requests.erase(requests.begin()); // Dequeue

            printf("[GSM TX]: %s\n", currentRequest->command.c_str());
            currentResponseBlock = ""; // Clear previous response block

            // Check if this is the PDU data part (contains Ctrl+Z)
            if (currentRequest->command.find('\x1A') != std::string::npos) {
                 gsm.print(currentRequest->command.c_str()); // Send PDU + Ctrl+Z directly
                 // Don't add CR here
                 state = SerialRunState::SENDING_PDU_DATA;
                 lastCommandTime = std::chrono::steady_clock::now();
            } else {
                // Standard AT command
                gsm.print(currentRequest->command.c_str());
                gsm.print('\r'); // Standard AT command termination
                state = SerialRunState::COMMAND_RUNNING;
                lastCommandTime = std::chrono::steady_clock::now();
            }
        }

        // --- Incoming Data Processing ---
        std::string incomingData = "";
        #ifdef ESP_PLATFORM
        while (gsm.available()) {
            char c = gsm.read();
            // Optional: Echo cancellation attempt (simple)
            // if (state != SerialRunState::NO_COMMAND && currentRequest && !currentRequest->command.empty()) {
            //     // Very basic echo check - might need refinement
            //     if (c == currentRequest->command[echoCheckPos]) {
            //         echoCheckPos++;
            //         if (echoCheckPos >= currentRequest->command.length()) {
            //             // Potential echo matched, reset check
            //             echoCheckPos = 0;
            //         }
            //         continue; // Skip adding char if it matches expected echo
            //     } else {
            //         // Mismatch, assume not echo, reset check
            //         echoCheckPos = 0;
            //     }
            // }
            incomingData += c;
        }
        #endif

        if (!incomingData.empty()) {
            // printf("[RAW RX]: %s\n", incomingData.c_str()); // Very verbose debug
            lineBuffer += incomingData;
        }

        size_t lineEndPos;
        // Process complete lines (\n terminated) in the buffer
        while ((lineEndPos = lineBuffer.find('\n')) != std::string::npos)
        {
            std::string line = lineBuffer.substr(0, lineEndPos);
            lineBuffer.erase(0, lineEndPos + 1); // Remove processed line + '\n'

            // Clean up the line (remove CR, trim whitespace)
            if (!line.empty() && line.back() == '\r') line.pop_back();
            line.erase(0, line.find_first_not_of(" \t\r\n"));
            line.erase(line.find_last_not_of(" \t\r\n") + 1);

            if (line.empty()) continue; // Skip empty lines

            // printf("[GSM RX Line]: %s\n", line.c_str()); // Verbose Debug

            // --- Simple Echo Check (if ATE1 is potentially active) ---
            // If a command is running and the received line exactly matches the command sent
            // (ignoring the PDU data part which doesn't echo predictably)
            if ((state == SerialRunState::COMMAND_RUNNING) && currentRequest &&
                 line == currentRequest->command)
            {
                 printf("[GSM] Echo ignored: %s\n", line.c_str());
                 continue; // Skip processing this line as echo
            }

            // --- URC Processing ---
            // Check if the line starts with a known URC prefix AND no command is active,
            // OR if a command IS active but the line is NOT a final identifier for that command.
            bool potentialURC = isURC(line);
            bool isFinalReply = isEndIdentifier(line);

            if (potentialURC && (state == SerialRunState::NO_COMMAND || !isFinalReply)) {
                processURC(line);
                // URC processed, continue to next line in buffer without affecting command state
                continue;
            }

            // --- Command Response Processing ---
            if (state == SerialRunState::COMMAND_RUNNING || state == SerialRunState::SENDING_PDU_DATA)
            {
                // Append line to the current response block
                currentResponseBlock += line + "\n";

                // Check for PDU prompt '>' specifically for the AT+CMGS command's *first* part
                // It should be the only thing on the line (after trimming)
                bool isPduPrompt = (line == ">" && state == SerialRunState::COMMAND_RUNNING);

                // Check if this line is a final response identifier OR the PDU prompt
                if (isFinalReply || isPduPrompt)
                {
                    // printf("[GSM Resp Block]:\n%s---\n", currentResponseBlock.c_str()); // Debug full block

                    bool executeNext = false; // Flag if callback wants to chain next command
                    if (currentRequest && currentRequest->callback) {
                        // Pass the accumulated block to the callback
                        executeNext = currentRequest->callback(currentResponseBlock);
                    }

                    // --- State Transition Logic ---

                    // Case 1: PDU prompt received, callback returned true (wants to send PDU data)
                    if (isPduPrompt && executeNext && currentRequest && currentRequest->next) {
                        // Queue the next part (PDU data send)
                        requests.insert(requests.begin(), currentRequest->next);
                        printf("[GSM] PDU prompt handled, queuing PDU data send.\n");
                        // The current request (AT+CMGS=len) is finished.
                        currentRequest = nullptr;
                        // State remains active, waiting for the next command (PDU data) to be sent
                        // which will happen on the next run() iteration. Reset state to NO_COMMAND
                        // so the PDU send command can be picked up immediately.
                        state = SerialRunState::NO_COMMAND;
                        currentResponseBlock = ""; // Clear block for next command
                    }
                    // Case 2: Final reply received (OK, ERROR, etc.)
                    else if (isFinalReply) {
                        // If chaining was requested by callback AND there's a next command
                        if (executeNext && currentRequest && currentRequest->next) {
                            requests.insert(requests.begin(), currentRequest->next);
                            printf("[GSM] Chaining next request.\n");
                        }
                        // Command (or chain part) is complete
                        currentRequest = nullptr;
                        state = SerialRunState::NO_COMMAND; // Ready for next command
                        currentResponseBlock = ""; // Clear block
                    }
                    // Case 3: PDU prompt received, but callback didn't return true or no next command
                    // (This shouldn't happen for CMGS if structured correctly, but handle defensively)
                    else if (isPduPrompt) {
                         printf("[GSM] PDU prompt received but no chaining requested or possible.\n");
                         // Treat as command finished (likely an error in setup)
                         currentRequest = nullptr;
                         state = SerialRunState::NO_COMMAND;
                         currentResponseBlock = "";
                    }
                    // else: Not a final reply or PDU prompt, continue accumulating lines.

                } // End if (isFinalReply || isPduPrompt)

            } // End if (state == COMMAND_RUNNING || state == SENDING_PDU_DATA)
            else if (!potentialURC) { // No command running, and not a recognized URC
                 printf("[GSM] Unexpected data (State: NO_COMMAND): %s\n", line.c_str());
            }

        } // End while loop processing lines in buffer


        // --- Timeout Check ---
        if (state != SerialRunState::NO_COMMAND) {
            auto timeout = (state == SerialRunState::SENDING_PDU_DATA) ? pduTimeoutDuration : commandTimeoutDuration;
            if ((std::chrono::steady_clock::now() - lastCommandTime) > timeout) {
                printf("[GSM] Command Timeout! State: %d, Command: %s\n",
                       static_cast<int>(state),
                       currentRequest ? currentRequest->command.c_str() : "N/A");

                if (currentRequest && currentRequest->callback) {
                    // Call callback with timeout indication (pass a specific error string)
                    currentRequest->callback("TIMEOUT_ERROR"); // Callback should handle this string
                }
                // Reset state forcefully
                currentRequest = nullptr;
                currentResponseBlock = "";
                lineBuffer = ""; // Clear potentially stuck partial line
                state = SerialRunState::NO_COMMAND;
            }
        }
    } // End of run()


    // --- Main Loop Function (using PaxOS event handler) ---
    void loop()
    {
        // High frequency checks (Signal Quality)
        eventHandlerGsm.setInterval([&]() {
            refreshNetworkQuality();
        }, 5000); // Check roughly every 5 seconds

        // Medium frequency checks (Connection, Voltage, PIN, Time)
        eventHandlerGsm.setInterval([&]() {
            printf("[GSM] Running medium frequency checks.\n");
            refreshConnectionStatus();
            refreshVoltage();
            refreshPinStatus();
        }, 30000); // Check roughly every 30 seconds

        // Low frequency checks (Time Sync)
        eventHandlerGsm.setInterval([&]() {
            Time::syncNetworkTime();
        }, 60 * 60 * 1000); // Check roughly every hour (in milliseconds)


        // Main execution loop
        while (true) {
            run(); // Process GSM commands and responses

            eventHandlerGsm.update(); // Update the timer events

            PaxOS_Delay(5); // Small delay to prevent busy-waiting, and allow other tasks to run
        }
    }

} // namespace Gsm